<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja" >
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<meta name="keywords" content="DBFlute,Seasar(S2Container),SelectableDataSource,SelectableDataSourceProxy,冗長化,DB切り替え" />
	<style type="text/css" title="currentStyle">@import "../../../../css/sub.css";</style>
	<title>LastaFluteでMaster/SlaveDB | LastaFlute</title>
</head>
<body>
<div id="container" class="ct-manual">
<div id="mainbar"><div id="header">
	<a href="#">DBFlute<span>DB変更に強いO/Rマッパー</span></a>
	<img src="../../../../image/logo-content.gif" alt="logo"/>
	<ul>
		<li class="hd-introduction"><a href="#">Introduction</a></li>
		<li class="hd-tutorial"><a href="#">Tutorial</a></li>
		<li><ul><li class="hd-architect"><a href="#">for Architect</a></li><li class="hd-developer"><a href="#">for Developer</a></li></ul></li>
		<li class="hd-environment"><a href="#">Environment</a></li>
		<li><ul><li class="hd-install"><a href="#">Install</a></li><li class="hd-upgrade"><a href="#">Upgrade</a></li></ul></li>
		<li class="hd-manual"><a href="#">Manual</a></li>
	</ul>
</div>

<div id="content"><!-- __content-start__ -->
	<h1>LastaFluteでMaster/SlaveDB</h1>
	${indexlist}

	<h2 id="overview">master/slave対応の概要</h2>
	<p>
		同じ Schema に対して、MasterDB と SlaveDB と二つ以上のDBを用意する、Master/SlaveDB
		構成のときの LastaFlute でのデフォルトのやり方が存在します。
	</p>
	<h3 id="masterslaveprecondition">master/slaveの目的</h3>
	<p>
		そもそもの master/slave の目的として、以下のことを想定しています。
	</p>
	<ul>
		<li>A. MasterDB に障害が発生したら SlaveDB が代わってサービス継続</li>
		<li>B. 検索の一部をslaveにして、DBサーバーの負荷分散</li>
	</ul>
	<p>
		A だけであればアプリは意識しないのであまり関係ありませんが、B を<span class="frm">(アプリで)</span>やるのであれば意識する必要があります。
		<span class="frm">(アプリとDBの間にロードバランサーがいて自動で振り分けるなら意識しない)</span>
	</p>
	<h3 id="masterslaveflow">master/slave対応の流れ</h3>
	<p>
		LastaFluteでの master/slave 対応は、以下のような流れです。
	</p>
	<ul>
		<li>master/slaveごとのDataSourceを統合した切り替え可能DataSource作成</li>
		<li>アプリ実行時にどっちを使うかを指定する <span class="frm">(明示か暗黙かはアプリの都合次第)</span></li>
	</ul>
	<p>
		それを、LastaFluteでのオーソドックスな実装に当てはめるとこのようになります。
	</p>
	<ul>
		<li>SelectableDataSourceProxy を想定した Di xml 構造を構築する</li>
		<li>SlaveDBAccessor で SlaveDB に検索する <span class="frm">(ここはアプリの都合の良い形にカスタマイズ)</span></li>
	</ul>
	<h3 id="keypointclass">キーポイント: SelectableDataSourceProxy</h3>
	<p>
		SelectableDataSourceProxy がキーポイントとなります。
		DBFluteが使う DataSource を、この Proxy に差し替え、動的に master と slave の DataSource
		を差し替えられるようにします。 
	</p>
	<p>
		このクラス自体は、もともと master/slave のための機能ではなく、冗長化複数DBのための機能です。
		master/slaveも冗長化複数DBの一つのパターンとして捉えています。
	</p>
	<p>
		ただ、実際にコンポーネント登録するクラスは、SelectableDataSourceProxy を継承して、
		master/slave に最適化させた <em class="mark">MasterBasisSelectableDataSource</em> です。
	</p>
<pre><span class="codetitle">e.g. Master/SlaveDBの DI xml の include 構成 @ClassModel</span><code>
javax.sql.DataSource
 ^
 |-SelectableDataSourceProxy <span class="comment">// 冗長化複数DBのためのクラス</span>
    ^
    |-MasterBasisSelectableDataSource <span class="comment">// master/slaveのためのクラス</span>
</code></pre>

	<h2 id="strategy">master/slaveの実装戦略</h2>
	<p>
		アプリでmaster/slaveを導入する場合、<em class="keyword">アプリの業務コードでどのようにmasterとslaveを意識して実装するか？</em>
		それによって準備する内容が変わります。
	</p>
	<h3 id="expectedstrategy">想定戦略パターン</h3>
	<p>
		大きく四つの戦略パターンを想定しています:
	</p>
	<dl class="lolongkeymainlist">
		<dt>A. master基軸でslaveつど指定</dt><dd>slaveにしたい検索だけ狙って切り替え</dd>
		<dt>B. slave基軸でmasterアノテーション指定</dt><dd>Action単位でmaster or slave</dd>
		<dt>C. slave基軸で更新時master自動切り替え</dt><dd>更新系を実行した時点でmasterに</dd>
		<dt>D. インフラ側で自動切り替え</dt><dd>ロードバランサーなどで自動的に振り分け</dd>
	</dl>
	<h3 id="lastaflutebasicstrategy">LastaFluteの基本想定</h3>
	<p>
		LastaFluteで提供しているクラスは、"A" の "master基軸でslaveつど指定" を基本想定としています。
		もちろん、"B" や "C" も実現できますが、アプリ側で少し実装を入れて適用させます。
	</p>
	<p>
		オフィシャルのドキュメントとしては、まずは "A" を前提として、"B" や "C" に関しては追加で説明を入れていきます。
	</p>
	<p>
		"D" の場合は、もはやアプリもフレームワークも何もする必要がない (と思われる) ので、特に書くことはありません。
	</p>
	<h3 id="basicimplimage">基本想定の実装イメージ</h3>
	<p>
		SlaveDBAccessorというインターフェースを使ったやり方の実装イメージです。
		<span class="frm">(戦略が変われば、これは使わないので、あくまで基本想定の理解のために)</span>
	</p>
<pre><span class="codetitle">e.g. SlaveDBAccessorを使ってSlaveDBを狙ってアクセス @Java</span><code>
@Resource
<span class="keyword">private</span> SlaveDBAccessor <span class="attribute">slaveDBAccessor</span>;

<span class="keyword">public void</span> sea() { <span class="comment">// デフォルトはmasterを向いている</span>
    <span class="comment">// 必ず slave に対して検索</span>
    List&lt;Member&gt; memberList = <span class="attribute">slaveDBAccessor</span>.accessFixedly(() -&gt; {
        <span class="keyword">return</span> <span class="attribute">memberBhv</span>.selectList(cb -&gt; <span class="abbreviation">...</span>);
    });

    <span class="comment">// 引数の判定次第で slave に対して検索</span>
    List&lt;Member&gt; memberList = <span class="attribute">slaveDBAccessor</span>.accessIfNeeds(() -&gt; {
        <span class="keyword">return</span> <span class="attribute">memberBhv</span>.selectList(cb -&gt; <span class="abbreviation">...</span>);
    }, isSlaveDB()); <span class="comment">// 何かしらアプリケーション的な判定</span>

    <span class="comment">// 引数の数値次第で半々に slave に対して検索</span>
    List&lt;Member&gt; memberList = <span class="attribute">slaveDBAccessor</span>.accessRandomFifty(() -&gt; {
        <span class="keyword">return</span> <span class="attribute">memberBhv</span>.selectList(cb -&gt; <span class="abbreviation">...</span>);
    }, getDeterminationNumber()); <span class="comment">// ランダム判定のためのlong</span>
}
</code></pre>
	<p>
		複数DB構成のときは、DIするSlaveDBAccessorの変数の型は、アプリでDBごとの継承クラス(具象クラス)になるかもしれません。
		<span class="frm">(仕組みの設計次第ですが、基本的にはそうなります)</span>
	</p>

	<h2 id="howto">master/slaveの設定方法</h2>
	<p>
		まず、<em class="mark">単一DB構成</em>、もしくは、<em class="mark">複数DBであってもメインスキーマ</em>
		であることを前提にした設定方法です。複数DB構成でのサブスキーマでのmaster/slaveはつどつど補足します。
	</p>
	<h3 id="dixmlstructure">Di xml構造</h3>
	<p>
		こういう Di xml構成を作ります。
	</p>
<pre><span class="codetitle">e.g. Master/SlaveDBの DI xml の include 構成 @Dixml</span><code>
app.xml <span class="comment">// 手作り: アプリの Di xml のルート</span>
 |
 |-dbflute.xml <span class="comment">// DBFlute自動生成: includes jta.xml, jdbc.xml, tx_aop.xml</span>
 |  |
 |  |-rdb.xml <span class="comment">// Lasta Di組込み: includes jta.xml, jdbc.xml, tx_aop.xml</span>
 |  |  |
 |  |  |-jta.xml <span class="comment">// Lasta Di組込み: TransactionManager, UserTransactionなど</span>
 |  |  |-<span class="subpoint">(jdbc.xml)</span> <span class="comment">// LastaFlute組込み: jdbc+.xmlに上書きされる</span>
 |  |  |-tx_aop.xml <span class="comment">// Lasta Di組込み: まあ、気にしなくていい</span>
 |  |  |
 |  |  |-<span class="point">jdbc+.xml</span> <span class="comment">// ☆手作り: SelectableDataSourceProxy(dataSource)を定義</span>
 |  |  |  |
 |  |  |  |-<span class="point">plugin/selectable_datasource.xml</span> <span class="comment">// LastaFlute組込み: SelectableDataSourceHolderの定義</span>
 |  |  |  |
 |  |  |  |-<span class="point">jdbc-master.xml</span> <span class="comment">// ☆手作り: master用のjdbc.xml</span>
 |  |  |  |  |
 |  |  |  |  |-jta.xml <span class="comment">// ConnectionPoolなどがTransactionManagerを使うため</span>
 |  |  |  |  |-lastaflute_assist.xml <span class="comment">// [app]_config.propertiesを使うため</span>
 |  |  |  |
 |  |  |  |-<span class="point">jdbc-slave.xml</span> <span class="comment">// ☆手作り: slave用のjdbc.xml</span>
 |  |  |  |  |
 |  |  |  |  |-jta.xml <span class="comment">// masterと同じ</span>
 |  |  |  |  |-lastaflute_assist.xml <span class="comment">// masterと同じ</span>
<span class="abbreviation">...</span> 
</code></pre>
	<h3 id="dixmljdbcplus">jdbc+.xml</h3>
	<p>
		アプリで jdbc+.xml を作成します。<span class="frm">("+" を付けると、LastaFlute組込みの jdbc.xml が完全上書きされます)</span>
	</p>
	<p>
		ここで SelectableDataSourceProxy をコンポーネント定義することで、
		DBFlute が利用する DataSource がProxy化され、masterに接続するのかslaveに接続するのか切り分けられます。
		また、SlaveDBAccessor も定義することで、アプリで SlaveDB に狙ってアクセスできます。
	</p>
	<div class="relatedpage"><a href="../../lastadi/dixmlexp.html">Di xml の Expression</a></div>
<pre><span class="codetitle">e.g. jdbc+.xml for master/slave  @Dixml</span><code>
&lt;components namespace=<span class="literal">"jdbc"</span>&gt;
    &lt;include path=<span class="literal">"plugin/selectable_datasource.xml"</span>/&gt;
    &lt;include path=<span class="literal">"jdbc-master.xml"</span>/&gt;
    &lt;include path=<span class="literal">"jdbc-slave.xml"</span>/&gt;
    &lt;component name=<span class="literal">"dataSource"</span> class=<span class="literal">"org.lastaflute.db.replication.slavedb.MasterBasisSelectableDataSource"</span>/&gt;
    &lt;component name=<span class="literal">"slaveDBAccessor"</span> class=<span class="literal">"org.lastaflute.db.replication.slavedb.SlaveDBAccessorImpl"</span>/&gt;
&lt;/components&gt;
</code></pre>
	<p>
		ただ、SelectableDataSourceProxyは、別に Master/SlaveDB
		専用のクラスではなく、デフォルトのDBを定めていませんので、実際に登録する具象クラスは、MasterBasisSelectableDataSource
		にすると良いでしょう。そうすると、DataSourceのキーを何も指定してないときに、MasterDB をアクセスするようになります。
		<span class="frm">(SelectableDataSourceProxyだと、何も指定されていなければ例外)</span>
	</p>
	<p>
		SelectableDataSourceProxy が、SelectableDataSourceHolder を利用するので、LastaFlute組込みの
		plugin/selectable_datasource.xml を include します。<span class="frm">(複数DBでサブスキーマの場合はここの設定が変わります: 後述)</span>
	</p>
	<p>
		SelectableDataSourceProxy のコンポーネント名は、DBFluteがDataSourceをDIするときに使う名前にします。
		複数DB構成とかにしていなければ、多くの場合デフォルトの "dataSource" でOKです。
		<span class="frm">(厳密には、DBFluteも型でDIするので、複数DBであってもあまり名前は関係ないかもです)</span>
	</p>
	<p>
		slaveDBAccessorは、(単一DB構成なら)組み込みのSlaveDBAccessorImplでも基本的には問題ないですが、もし将来、複数DB構成かつ
		"複数DB master/slave" になったら "SlaveDBAccessorインターフェース" でのDIが曖昧になってしまいます。
		なので、将来DB増えてあっちでもこっちでもmaster/slaveやりそうという想像ができるのであれば、
		最初からSlaveDBAccessorImplを継承したアプリでDBごとのクラスを作成して登録します。
	</p>
	<h4 id="dixmljdbcplusmultipledb">複数DB構成の場合 <span class="frm">(jdbc+.xml)</span></h4>
	<p>
		複数DB構成でサブスキーマの場合、selectable_datasource.xml は include せず、
		ThreadLocalSelectableDataSourceHolder を継承したアプリでDBごとのクラスを作成して登録します。
		<span class="frm">(ThreadLocalをDBごとに独立させるため: でないとmaster/slaveの向き先が混在してしまう)</span>
	</p>
	<p>
		dataSourceのコンポーネント名は、サブスキーマであっても "dataSource" で問題ないかもですが、名前でDIをする場面などアプリで必要であれば
		"[スキーマ名]DataSource" にしておきましょう。
	</p>
	<p>
		slaveDBAccessorは、SlaveDBAccessorImplを継承したアプリでDBごとのクラスを作成して登録します。
		サブスキーマだけでなくメインスキーマも作成した方が無難です。
		<span class="frm">(アプリ内でSlaveDBAccessorインターフェースでDIが曖昧になるため、DBごとの具象クラスでDIできるように)</span>
	</p>
	<h3 id="dixmljdbcmaster">jdbc-master.xml</h3>
	<p>
		アプリで、jdbc-master.xml を作成します。
	</p>
	<p>
		内容は、LastaFlute組込みの jdbc.xml を参考にして、master用に書き換えたものにします。
	</p>
	<p>
		ただ、DataSourceコンポーネントに関しては<span class="frm">(xaDataSourceの方ではありません)</span>、コンポーネント名を masterDataSource
		に変更します。仕組みの中では、そのコンポーネント名で特定しますので重要です。
	</p>
	<p>
		また、provider.config().getXxx() 部分は、デフォルトの接続設定をmasterのものとして扱うのであればそのままでOKです。
		<span class="frm">([app]_env.properties上で master.jdbc... と明示したいのであれば修正してFreeGenしてDi xml上も直します)</span>
	</p>
	<h4 id="dixmljdbcmastermultipledb">複数DB構成の場合 <span class="frm">(jdbc-master.xml)</span></h4>
	<p>
		複数DB構成の場合は、サブスキーマの方は jdbc-[スキーマ名]-master.xml という名前にして区別できるようにします。
	</p>
	<p>
		また、DataSourceコンポーネント名も master[スキーマ名]DataSource という名前にして区別できるようにします。
		ここは切り替えする際に参照される名前なので重要です。
	</p>
	<p>
		メインスキーマであっても jdbc-[スキーマ名]-master.xml という名前にした方が紛らわしくないです。
		一方で、メインスキーマのDataSourceコンポーネント名は、SlaveDBAccessorのデフォルト設定に合わせて masterDataSource
		のままでOKです。(アプリで拡張して名前設定を変えていなければ)
	</p>
	<h3 id="dixmljdbcslave">jdbc-slave.xml</h3>
	<p>
		アプリで、jdbc-slave.xml を作成します。
	</p>
	<p>
		内容は、LastaFlute組込みの jdbc.xml を参考にして、slave用に書き換えたものにします。
	</p>
	<p>
		ただ、DataSourceコンポーネントに関しては<span class="frm">(xaDataSourceの方ではありません)</span>、コンポーネント名を slaveDataSource
		に変更します。仕組みの中では、そのコンポーネント名で特定します。
	</p>
	<p>
		また、provider.config().getXxx() 部分は、それぞれ [app]_env.propertiesにて slave用のプロパティを定義して FreeGen
		でメソッドを自動生成して、それに合わせて Di xml での参照も修正しましょう。
	</p>
	<p>
		すべて slave.jdbc... と分離させるのか？slave固有のものだけslave用プロパティを作成して共通のものはmasterの設定を再利用するか？
		ここはアプリの要件に合わせて調整すると良いです。
	</p>
	<h4 id="dixmljdbcslavemultipleslave">複数SlaveDBの場合 <span class="frm">(jdbc-slave.xml)</span></h4>
	<p>
		もし、複数SlaveDB (一つのDBスキーマに付き、複数のSlaveDBがあるケース) では、ファイル名やコンポーネント名の "slave" 部分を slaveSea や slaveLand
		などにして、SlaveDBの数だけ追加します。ただし、そのケースでは SlaveDBAccessor はそのままでは利用できません。
		<span class="frm">(SlaveDBAccessorは、基本的にslaveが一つであることを前提に実装されています)</span>
	</p>
	<p>
		何かしら複数のslaveに自動で振り分ける仕組みを別途挟み込む必要があるでしょう。
		<span class="frm">(アプリ作成のSlaveDBAccessorの継承クラスで、そういった仕組みを実装するとか)</span>
	</p>
	<h4 id="dixmljdbcslavemultipledb">複数DB構成の場合 <span class="frm">(jdbc-slave.xml)</span></h4>
	<p>
		複数DB構成に関しては、先述のmasterの方と同じ話となります。
	</p>
	<h3 id="whenupgradelasta">LastaFluteをアップグレードするとき</h3>
	<p>
		アプリで、LastaFlute組込みの定義(jdbc.xml)やクラスを意識することになるので、めったには変わりませんが、LastaFlute
		のアップグレードをするときには必ずmaster/slave周りを意識して動作確認をしてください。<span class="frm">(万が一、構造や名前が変わったりしたときのために)</span>
	</p>

	<h2 id="appextended">アプリでの継承クラスの作り方</h2>
	<p>
		主に複数DB構成の場合は、LastaFluteで組み込まれてるクラスをアプリで継承して固有のクラスとして扱うことが多いです。
	</p>
	<h3 id="bizfwpackage">bizfwパッケージ</h3>
	<p>
		それら継承クラスは、bizfwパッケージ配下に (例えば) masterslave というパッケージを作って、その下に配置すると良いでしょう。
	</p>
	<p>
		さらに、その配下にDBスキーマごとのパッケージを作って、DBスキーマ依存のクラスを区別できるようにすると良いでしょう。
	</p>
<pre><span class="codetitle">e.g. bizfw配下のパッケージ構成 @Dixml</span><code>
[root]
 |-app
 |-bizfw
 |  |-<span class="abbreviation">...</span>
 |  |-masterslave
 |  |  |
 |  |  |-maihamadb    <span class="comment">// main schema</span>
 |  |  |  |-MaihamadbSlaveDBAccessor.java
 |  |  |
 |  |  |-resortlinedb <span class="comment">// sub schema</span>
 |  |  |  |-ResortlineSlaveDBAccessor.java
 |  |  |  |-ResortlineDBSelectableDataSourceHolder.java
 |  |
 |  |-<span class="abbreviation">...</span>
 |  |
 |-dbflute
 |-mylasta
</code></pre>
	<h3 id="slavedbaccessor">SlaveDBAccessor</h3>
	<p>
		基本的には組み込みのSlaveDBAccessorImplを継承します。
	</p>
	<p>
		メインスキーマの場合、特にオーバーライドするものはありません。
		固有クラスを作ってDIするときに型でインスタンスを判別できれば良いだけなので、中の実装は空っぽでもOKです。
		<span class="frm">(もちろん、メインスキーマでもDataSourceコンポーネント名にスキーマ名が入っていればその限りではなく、サブスキーマと同じ実装をする必要があります)</span>
	</p>
	<p>
		サブスキーマの場合、mySchemaKeyword()メソッドをオーバーライドします。
		DataSourceコンポーネント名を識別するためのキーワードを戻すようにします。
		先頭文字は小文字でOKです。コンポーネント名の構築時に自動的に先頭大文字になります。
	</p>
	<p>
		toString()のオーバーライドは必須ではありませんが、ログなどでDBを識別するのに使うこともあるので、オーバーライドしてスキーマが区別しやすい文字列にしておくと良いです。
		<span class="frm">(メインスキーマでもサブスキーマでも)</span>
	</p>
	<h3 id="slavedbaccessor">SelectableDataSourceHolder</h3>
	<p>
		xxx
	</p>
	
	<h2 id="appimpl">アプリでの実装方法</h2>
	<h3 id="betaway">ひとまず、ベタなやり方</h3>
	<p>
		まずやらない方法ですが、<em class="keyword">アプリでの非常に単純でベタな実装方法</em> は以下のようになります。
		<span class="frm">(仕組みの理解のために説明します)</span>
	</p>
<pre><span class="codetitle">e.g. SelectableDataSourceHolder を直接使ったベタな実装方法 @Java</span><code>
@Resource
<span class="keyword">private</span> MemberBhv <span class="attribute">memberBhv</span>;
@Resource
<span class="keyword">private</span> SelectableDataSourceHolder <span class="attribute">selectableDataSourceHolder</span>; <span class="comment">// injected</span>

<span class="keyword">public void</span> fooAndBar() {
    <span class="attribute">selectableDataSourceHolder</span>.switchSelectableDataSourceKey(<span class="literal">"master"</span>);
    <span class="attribute">memberBhv</span>.update(member); <span class="comment">// master の会員を更新</span>

    <span class="attribute">selectableDataSourceHolder</span>.switchSelectableDataSourceKey(<span class="literal">"slave"</span>);
    <span class="abbreviation">...</span> = <span class="attribute">memberBhv</span>.select(cb -&gt; <span class="abbreviation">...</span>); <span class="comment">// slave の会員を検索</span>
}
</code></pre>
	<p>
		SelectableDataSourceHolder は、LastaFlute に組み込まれている plugin/selectable_datasource.xml にて定義されています。
		デフォルトでは何の DataSource とも関連付いていないため、DBアクセスする前は必ず何かしらの DB を指定する必要があります。
	</p>
	<p>
		ただ、通常このような利用はあり得ず、仕組みをわかりやすく理解するための Example です。
	</p>
	<h3 id="accessorway">SlaveDBAccessorを使ったやり方</h3>
	<p>
		ベタなやり方だと内部構造に依存しまくりで使いやすくもないので、LastaFluteで提供されている SlaveDBAccessor
		を使うと良いでしょう。
	</p>
<pre><span class="codetitle">e.g. SlaveDBAccessorを使ってSlaveDBを狙ってアクセス @Java</span><code>
@Resource
<span class="keyword">private</span> SlaveDBAccessor <span class="attribute">slaveDBAccessor</span>;

<span class="keyword">public void</span> sea() {
    <span class="comment">// 必ず slave に対して検索</span>
    List&lt;Member&gt; memberList = <span class="attribute">slaveDBAccessor</span>.accessFixedly(() -&gt; {
        <span class="keyword">return</span> <span class="attribute">memberBhv</span>.selectList(cb -&gt; <span class="abbreviation">...</span>);
    });

    <span class="comment">// 引数の判定次第で slave に対して検索</span>
    List&lt;Member&gt; memberList = <span class="attribute">slaveDBAccessor</span>.accessIfNeeds(() -&gt; {
        <span class="keyword">return</span> <span class="attribute">memberBhv</span>.selectList(cb -&gt; <span class="abbreviation">...</span>);
    }, isSlaveDB()); <span class="comment">// 何かしらアプリケーション的な判定</span>

    <span class="comment">// 引数の数値次第で半々に slave に対して検索</span>
    List&lt;Member&gt; memberList = <span class="attribute">slaveDBAccessor</span>.accessRandomFifty(() -&gt; {
        <span class="keyword">return</span> <span class="attribute">memberBhv</span>.selectList(cb -&gt; <span class="abbreviation">...</span>);
    }, getDeterminationNumber()); <span class="comment">// ランダム判定のためのlong</span>
}
</code></pre>
	<p>
		万が一、SlaveDBのメソッド内で更新処理をしてしまったとしても、更新処理は自動的に master にアクセスします。
		SlaveDBAccessorには、そういった安全対策が施されています。
	</p>
	<h3 id="originalway">独自に振り分けるやり方</h3>
	<p>
		明示するのではなく何かのきっかけで自動的に切り替えるなど、独自のルールで切り替えるときは、(LastaFluteなら)ActionHookなどの共通処理で切り替えます。
		デフォルトのDBの設定と切り替えのロジックを実装します。
	</p>
	<p>
		例えば、通常は MasterDB の方にDBアクセスし、SlaveDB
		を示すアノテーションがメソッドに定義されていたら、そのメソッド内だけ SlaveDB
		にDBアクセスするというやり方が考えられます。
	</p>
<pre><span class="codetitle">e.g. 独自に振り分けるアプリのInterceptorの実装 @Java</span><code>
@Resource
<span class="keyword">private</span> SelectableDataSourceHolder <span class="attribute">selectableDataSourceHolder</span>; <span class="comment">// injected</span>

<span class="keyword">public</span> Object invoke(MethodInvocation invocation) <span class="keyword">throws</span> Throwable {
    String current = <span class="attribute">selectableDataSourceHolder</span>.getSelectableDataSourceName();
    <span class="keyword">try</span> {
        String selectableName = deriveSelectableDataSourceKey();
        <span class="attribute">selectableDataSourceHolder</span>.switchSelectableDataSourceKey(selectableName);
        <span class="keyword">return</span> invocation.proceed();
    } <span class="keyword">finally</span> {
        <span class="attribute">selectableDataSourceHolder</span>.switchSelectableDataSourceKey(current);
    }
}

<span class="keyword">protected</span> String deriveSelectableDataSourceKey(MethodInvocation invocation) {
    <span class="keyword">if</span> (hasSlaveAnnotation(invocation)) {
        <span class="keyword">return</span> <span class="literal">"slave"</span>;
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="literal">"master"</span>; <span class="comment">// MasterDB as default</span>
    }
}

<span class="keyword">protected</span> <span class="keyword">boolean</span> hasSlaveAnnotation(MethodInvocation invocation) {
    <span class="comment">// メソッドに SlaveDB を示すアノテーションが付いていたら true</span>
    <span class="comment">// (そのアノテーションは自作)</span>
    <span class="keyword">return</span> <span class="abbreviation">...</span>
}
</code></pre>
<pre><span class="codetitle">e.g. 独自に振り分けたときのアプリの実装 (Logic) @Java</span><code>
@Resource
<span class="keyword">private</span> MemberBhv <span class="attribute">memberBhv</span>;
@Resource
<span class="keyword">private</span> PurchaseBhv <span class="attribute">purchaseBhv</span>;

<span class="point">@SlaveDB</span>
<span class="keyword">public</span> void selectHeavy() { <span class="comment">// このメソッド内のDBアクセスは全て SlaveDB へ</span>
    MemberCB cb = <span class="abbreviation">...</span>
    <span class="abbreviation">...</span> = <span class="attribute">memberBhv</span>.selectList(cb);
    PurchaseCB cb = <span class="abbreviation">...</span>
    <span class="abbreviation">...</span> = <span class="attribute">purchaseBhv</span>.selectList(cb);
}
</code></pre>
	<p>
		この Interceptor は、DBアクセスをする可能性のあるプロセスの入り口となるコンポーネント、
		および、DBアクセス先を切り替える可能性のあるコンポーネントに関連付けます。例えば、Page, Action, Service, Logicクラスなどです。
		バリデーションやバリデーションエラーなどの処理の中でDBアクセスをする場合は、それらメソッドにも関連付ける必要があります。
	</p>
	<p>
		一方で、SlaveDBに更新処理を実行しないように注意する必要があります。ここでの例で言えば、SlaveDB
		アノテーションが付与されているメソッド内で insert() や upadte() を呼び出してはいけません。
		SlaveDBAccessorの中でやっているような、"すべり止め" 処理も入れると良いでしょう。
	</p>

	<h2 id="attentionplease">ちょこちょこ注意点</h2>
	<h3 id="twotransaction">Transactionは独立</h3>
	<p>
		Master と Slave のようなレプリケーション構成の場合は、そもそも更新処理を Master
		に集中させないといけないためあまり気にする必要はありませんが、TransactionはそれぞれのDBごとに独立したものになります。
		そのことだけはしっかり理解しておいた方が良いでしょう。
	</p>
	<h3 id="lazyslave">SlaveDBは遅延の可能性</h3>
	<p>
		master/slaveをどのように実現しているか次第ですが、RDBのmaster/slave機能の都合上、どうしてもmasterの更新からslaveへの反映までに遅延が発生する可能性があります。
		それを許容できない検索なのに slave を使ってしまうと、思わぬ事故を引き起こしてしまうかもしれませんので注意しましょう。
	</p>
	<h3 id="localenv">ローカル開発環境では、どうする？</h3>
	<p>
		ローカル開発環境で、master/slave構成がすんなり構築できるのであれば特に問題はありませんが、そうでない場合はちょっと注意が必要です。
	</p>
	<p>
		その場合、masterもslaveも同じDBを参照すれば、つじつまが合ってテストはおおよそできますが、UnitTest
		などで、masterとslaveに対するTransactionが同時に発行されるときはちょっと困ります。
	</p>
	<p>
		例えば、UnitTestの中でmasterに対して更新した結果が、slaveに対する検索で参照ができません。
		同じDBでも、Tranasction が(同時に)別になっているので、masterに対する更新が Commit
		されるまで、slaveの方の Tranasction ではその更新結果を検索できないのです。
		そこに依存しているロジックがあると、UnitTestがまともにできないという可能性もあります。
	</p>
	<p>
		しょっちゅう出てくる問題ではないと思うので、問題が出てくるまでお茶を濁すか、ローカルだけは SlaveDBAccessorNothing
		を使うようにするとか、工夫が必要でしょう。<span class="frm">(ローカルで簡単にmaster/slaveができちゃえば一番世話ないですが)</span>
	</p>
	<h3 id="multipledb">複数DB構成だと、どうする？</h3>
	<p>
		いくつか注意が必要です。ざっくり書いておきます
	</p>
	<ul>
		<li>組込みjdbc.xmlではないので、jdbc+.xmlじゃなく、jdbc-[スキーマ名].xml を作成することになる</li>
		<li>コンポーネント名が、シンプルだとバッティングするので、[スキーマ名]DataSource など修飾することになる</li>
		<li>SlaveDBAccessor をスキーマごとにクラスを作って、mySchemaKeyword() をオーバーライド</li>
	</ul>
<!-- __content-end__ --></div></div>

<div id="sidebar">
	<ul>
		<li><a href="#">inu</a></li>
		<li><a href="#">neko</a></li>
	</ul>
</div>
<div id="footer">
	<ul>
		<li><a href="#">SiteMap</a></li>
		<li><a href="https://www.seasar.org/issues/browse/DBFLUTE">BTS</a></li>
		<li><a href="http://d.hatena.ne.jp/jflute">Author's Blog</a></li>
	</ul>
</div>
</div>
</body>
</html>